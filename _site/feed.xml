<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://localhost:4000/switchBoard/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/switchBoard/" rel="alternate" type="text/html" /><updated>2017-11-13T11:57:39-08:00</updated><id>http://localhost:4000/switchBoard/</id><title type="html">SwitchBoard Home Automation</title><subtitle>Node.js home automation system with machine learning</subtitle><entry><title type="html">Automation Without Expense</title><link href="http://localhost:4000/switchBoard/Automation-Without-Expense/" rel="alternate" type="text/html" title="Automation Without Expense" /><published>2017-11-13T00:00:00-08:00</published><updated>2017-11-13T00:00:00-08:00</updated><id>http://localhost:4000/switchBoard/Automation%20Without%20Expense</id><content type="html" xml:base="http://localhost:4000/switchBoard/Automation-Without-Expense/">&lt;p&gt;When I speak to people about getting into home automation, one of their first responses is that they don’t want to go through all the expense to buy smart devices.  Maybe they rent their home and don’t want the hassle of setting things up to only have to tear it out later.&lt;/p&gt;

&lt;p&gt;Wouldn’t it be nice if you could try out some automation functionality before you take the plunge on a new expensive product?  SwitchBoard was built with the idea that automation should not be expensive.  If you have a working computer, you can spend exactly $0 and still get some great functionality.  Although it was built for low-performance machines to run on their own, there’s no reason it cannot be run in the background of your current computer.  With just a running instance of SwitchBoard, there’s a chance that some of your existing products can already be used - even if they’re not thought of as particularly “smart”.  Take a look at the &lt;a href=&quot;https://github.com/imbrianj/switchBoard#supported-devicesservices&quot;&gt;Supported Devices List&lt;/a&gt; and you may spot your TV or stereo.  You may also see different services that you could get some use of.  If you care about weather, sports, news, Travis CI etc - you can grab that data and do “stuff” with it.  What that “stuff” is depends on your needs.  Your actions they trigger may be desktop notifications, text to speech, push notifications even text messages.  With those tools alone, you can build up a pretty compelling piece of functionality.&lt;/p&gt;

&lt;p&gt;I’d considered building a multi-user, Internet-based equivalent for a lot of these services so you could abstract as many non-physical IoT pseudo-devices into a single cloud service with it’s own API and interface.  Someday, maybe.&lt;/p&gt;</content><author><name></name></author><category term="home automation" /><category term="general" /><summary type="html">When I speak to people about getting into home automation, one of their first responses is that they don’t want to go through all the expense to buy smart devices. Maybe they rent their home and don’t want the hassle of setting things up to only have to tear it out later.</summary></entry><entry><title type="html">Developing on a Moving Target</title><link href="http://localhost:4000/switchBoard/Developing-on-a-Moving-Target/" rel="alternate" type="text/html" title="Developing on a Moving Target" /><published>2017-11-08T00:00:00-08:00</published><updated>2017-11-08T00:00:00-08:00</updated><id>http://localhost:4000/switchBoard/Developing%20on%20a%20Moving%20Target</id><content type="html" xml:base="http://localhost:4000/switchBoard/Developing-on-a-Moving-Target/">&lt;p&gt;Sometimes, maintaining a complex piece of code that relies on third parties for code dependencies, APIs or software support can come with some significant risks and disadvantages.  Some of these can be mitigated while others must be either addressed or abandoned.&lt;/p&gt;

&lt;p&gt;From the start, SwitchBoard was built with the intention of having the fewest number of dependencies as reasonably possible.  The non-developer dependencies are limited to only &lt;a href=&quot;https://david-dm.org/imbrianj/switchboard#info=dependencies&quot;&gt;three core packages&lt;/a&gt;.  I intentionally peg these to very specific versions so I can have very granular control over their updates and make sure they work.  This is more a product of my OCD - but with so few, it’s not much of a burden for a repository that I work on so often.&lt;/p&gt;

&lt;p&gt;While npm packages are not a point of major pain, third party APIs sometimes are.  One example is the now intermittent Stocks API.  It’s fed from a YQL query that comes from Yahoo Finance.  One day, the feed started acting erratic.  I narrowed it down a bit to clearly be tied to some caching issues.  If the feed has interruption, you could simply append an additional stock and it would work again…for a while.  At the time, I worked at Yahoo, so I had the luxury of contacting the team responsible for the API.  Since the API itself was not official, they were unable to offer any type of official support for it.  So I’ve sort of let it rot.  It does work on occasion and I still use it myself - with some minor success.  Finding a working API is either not possible (licensing fees making it unable to scale for an open source project) or terribly hacky and brittle (parsing the HTML page for the values desired).&lt;/p&gt;

&lt;p&gt;Devices themselves have the great luxury of being shipped in great numbers.  My Samsung TV likely will not have any changes to it’s API.  This means for as long as I own the TV, I should expect (to some reasonable degree) that I’ll be able to make use of it with SwitchBoard.  However, Samsung took steps in later models to alter how they manage HTTP commands to be sent.  And this (evidentially) includes some encryption.  This &lt;a href=&quot;https://github.com/imbrianj/switchBoard/issues/55&quot;&gt;still remains unaddressed&lt;/a&gt;.  Not having physical access to the hardware makes development very difficult.  While some people have volunteered to help, it’s a difficult thing to do, even with hands-on access.  Admittedly, I’ve been stalling a bit in the hopes that someone can reveal additional information about how the new system works so that I can leverage their learnings.&lt;/p&gt;

&lt;p&gt;And finally is Chrome.  I love Chrome.  It has a ton of great functionality, it’s very modern and a pleasure to work with.  Mostly.  The Chrome team has (rightfully) started adding a lot of security features surrounding trusted sites.  One caveat to all this is that if you have a site that does not have SSL, some features will be disabled.  But these rules of trusting a site do not appear to be uniformly applied.  If you have no SSL, voice recognition will not work.  If you have a self-signed certificate, it will.  If you have no SSL, appcaching will work.  If you have a self-signed certificate, it will not.  Most people might ask why I don’t simply get a non-self-signed SSL certificate and be done with all this.  Since SwitchBoard is meant to be run on an intranet, it - to my knowledge - cannot be served any SSL certificate from an authorized signing authority.  Instead, you must rely on one that is not trusted - and either use it as an untrusted certificate or go to each machine and register that cert as being trusted.&lt;/p&gt;

&lt;p&gt;Okay, so you go through the trouble to finally get your system to use a self-signed SSL certificate.  You’ve gone to each machine on your network to register that cert so they know to trust it.  But now SmartThings no longer reports state back to SwitchBoard.  That’s because the &lt;a href=&quot;https://github.com/imbrianj/oauth_controller/blob/master/oauth_controller.groovy&quot;&gt;associated SmartThings app&lt;/a&gt; uses &lt;code class=&quot;highlighter-rouge&quot;&gt;sendHubCommand&lt;/code&gt; to send any state changes from the hub directly.  This keeps your network safer by not having to punch a hole through your firewall in order to get his bidirectional communication.  It’s also faster.  It’s just a better experience, in general.  But &lt;code class=&quot;highlighter-rouge&quot;&gt;sendHubCommand&lt;/code&gt;, to my knowledge, is a very simple system and &lt;a href=&quot;https://community.smartthings.com/t/sendhubcommand-to-https-endpoint/99297&quot;&gt;incapable of dealing with SSL&lt;/a&gt;.  So once you’re using SSL, those state updates are no longer received.  Bum out.&lt;/p&gt;</content><author><name></name></author><category term="home automation" /><category term="general" /><summary type="html">Sometimes, maintaining a complex piece of code that relies on third parties for code dependencies, APIs or software support can come with some significant risks and disadvantages. Some of these can be mitigated while others must be either addressed or abandoned.</summary></entry><entry><title type="html">Machine (Slowly) Learning</title><link href="http://localhost:4000/switchBoard/Machine-(Slowly)-Learning/" rel="alternate" type="text/html" title="Machine (Slowly) Learning" /><published>2017-11-07T00:00:00-08:00</published><updated>2017-11-07T00:00:00-08:00</updated><id>http://localhost:4000/switchBoard/Machine%20(Slowly)%20Learning</id><content type="html" xml:base="http://localhost:4000/switchBoard/Machine-(Slowly)-Learning/">&lt;p&gt;Is this thing on?&lt;/p&gt;

&lt;p&gt;When I first started adding machine learning to SwitchBoard, I had the expectation that it’d start revealing some interesting usage patterns.  That it’d start taking over a bit and let me stop focusing on how I interacted with my house.  It seemed natural to think that if it had a reasonable sized data set that it’d be able to take the user out of the equation at least somewhat.&lt;/p&gt;

&lt;p&gt;I was right.  And…well, I was also wrong.  So far, the end result has been pretty underwhelming.  Early on, I did not consider time or day variables.  Any action would be mapped to all similar actions.  To add some more fidelity to those results, I created sub-categories that events would be categorized by.  There would be four time variables: dawn, morning, afternoon and evening.  There would also be two day variables: weekday and weekend.  This is all well and good.  My behaviors change drastically between weekend evenings and, say, weekday mornings.  What I had naively not expected was how insanely high this set the bar on how much useful data one would need to collect before a reasonable level of confidence could surmise some useful responses.  We went from one bucket full of random events into &lt;code class=&quot;highlighter-rouge&quot;&gt;4 x 2 = 8&lt;/code&gt; buckets of events.  Some of these will be more full than others (I’m far more active in the afternoon than, say, dawn).  Because of this, I’ve been tweaking my confidence (how certain are we that, given the existing data, you want an intended action to be carried out?) and threshold numbers (how many events like this need to be logged before we should even consider acting on them?) down considerably to try and find where that happy level of usefulness is.&lt;/p&gt;

&lt;p&gt;Then there’s the issue of redundant scripts.  My house has learned that I like to have my hall light on after I arrive home.  But I already have written a script to enforce this - since I want it to do this before any learned behavior.  Why wait for 100 iterations when it’s something you automatically know will be desired 100% of the time?  So scriptable events still have their place - and they take over a fair bit of the work that machine learning otherwise would eventually handle.&lt;/p&gt;

&lt;p&gt;And then there’s the issue of redundant commands.  My house knows that when the motion sensor goes off during the day that my office light is on 95% of the time - so it should turn it on for me.  However, since the light is on 95% of the time, there’s a low likelihood that there’s anything to do at all.  Code has been written to prevent initiating an intent if the desired value is already the current state.  So it’s completely ignored.  So the machine learning reinforces existing behaviors and doesn’t leave a lot for it to do.  It silently dismisses an accurate but redundant intent.&lt;/p&gt;

&lt;p&gt;To further reduce any disagreements between a user and the machine learning script, any device that has had their state change within a given period will not be acted upon by any machine learning intent.  If you enter a room, switch on a light, then trigger an action that may want that light turned off, it may be fair to assume that we should ignore that implied intent since your action was presumably explicit.&lt;/p&gt;

&lt;p&gt;Things had been so quiet that I had to start adding logging data to my instance of SwitchBoard.  Watching the log as events fired, I could see it accurately reporting that either not enough data had been collected (something I can adjust numbers for and wait for more data to be collected), the confidence in that action was not high enough (which I can adjust - to a limit) or the target device already matched the intent.&lt;/p&gt;

&lt;p&gt;I still see huge potential in machine learning in this space.  My setup is, admittedly, fairly simple - and I still have only collected about a month of useful data.  I’ll be interested to see where things go once I collect more data, add in more functionality and find confidence and threshold values that make sense.  As this plays out, I intend to keep this blog updated.&lt;/p&gt;</content><author><name></name></author><category term="home automation" /><category term="machine learning" /><summary type="html">Is this thing on?</summary></entry><entry><title type="html">Old Talk</title><link href="http://localhost:4000/switchBoard/Old-Talk/" rel="alternate" type="text/html" title="Old Talk" /><published>2017-10-31T00:00:00-07:00</published><updated>2017-10-31T00:00:00-07:00</updated><id>http://localhost:4000/switchBoard/Old%20Talk</id><content type="html" xml:base="http://localhost:4000/switchBoard/Old-Talk/">&lt;p&gt;Several years ago, I gave a talk about Home Automation and the very beginnings of SwitchBoard (before that’s what it was called).  Many of my initial beliefs still stand true as a direction and aims for the project.&lt;/p&gt;

&lt;p&gt;Visit YouTube to &lt;a href=&quot;https://www.youtube.com/watch?v=B33KHgFjJsQ&quot;&gt;view it in full&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=B33KHgFjJsQ&quot;&gt;&lt;img src=&quot;https://img.youtube.com/vi/B33KHgFjJsQ/0.jpg&quot; alt=&quot;Early talk about SwitchBoard&quot; /&gt;&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="general" /><category term="home automation" /><summary type="html">Several years ago, I gave a talk about Home Automation and the very beginnings of SwitchBoard (before that’s what it was called). Many of my initial beliefs still stand true as a direction and aims for the project.</summary></entry><entry><title type="html">Installation</title><link href="http://localhost:4000/switchBoard/Install/" rel="alternate" type="text/html" title="Installation" /><published>2017-10-30T00:00:00-07:00</published><updated>2017-10-30T00:00:00-07:00</updated><id>http://localhost:4000/switchBoard/Install</id><content type="html" xml:base="http://localhost:4000/switchBoard/Install/">&lt;p&gt;To use SwitchBoard, you’ll need a working version of node.js and npm.  As node.js can run on a wide variety of platforms, I won’t go into the specifics of getting that set up.  There’s documentation available for most platforms that can do a better job of describing all the details there.  If you do have issues, I’m happy to try and point you in the right direction, though.&lt;/p&gt;

&lt;p&gt;Assuming you have &lt;code class=&quot;highlighter-rouge&quot;&gt;node&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;npm&lt;/code&gt; installed, you should be able to run something like this:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;node &lt;span class=&quot;nt&quot;&gt;--version&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; npm &lt;span class=&quot;nt&quot;&gt;--version&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and get an output similar to:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;v6.11.4
3.5.2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;SwitchBoard supports &lt;a href=&quot;https://github.com/imbrianj/switchBoard/blob/master/.travis.yml#L4-L14&quot;&gt;quite a range&lt;/a&gt; of different versions, so don’t worry too much about the specifics there.  We’re just looking for validation that the basic tools are available to us.&lt;/p&gt;

&lt;p&gt;Next, you’ll need to get the SwitchBoard code.  I typically just grab it via &lt;code class=&quot;highlighter-rouge&quot;&gt;git&lt;/code&gt; since it’s the easiest for me - but you can also &lt;code class=&quot;highlighter-rouge&quot;&gt;npm install switchboard-automation&lt;/code&gt; or grab the downloadable release file from (https://github.com/imbrianj/switchBoard/releases)[the GitHub page].  If you use git, you can simply:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone git@github.com:imbrianj/switchBoard.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and it’ll start downloading all the files.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/switchBoard/images/install/1.png&quot; alt=&quot;First few steps of the SwitchBoard installation: checking that npm and node are installed, getting the SwitchBoard source code and getting ready to install dependency packages.&quot; title=&quot;First few steps of the SwitchBoard installation&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Once the source files are downloaded, you’ll need to install all the required npm dependencies.  There are only 12 used by SwitchBoard (and 9 of them are just for development).  However, each of these packages have their own dependencies, so it may take a couple minutes on a slow machine to download, compile and install all of them.&lt;/p&gt;

&lt;p&gt;Once the packages are done installing, you should be able to start up SwitchBoard to make sure it’s working as expected:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;switchboard/
node app.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Once this is done, you should see log messages showing up in the console.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/switchBoard/images/install/2.png&quot; alt=&quot;Finish dependency installation and start up the unconfigured app.&quot; title=&quot;Make sure things are running&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If you don’t see any errors, you should be able to access the SwitchBoard web interface with the default URL of &lt;a href=&quot;http://localhost:8080&quot;&gt;http://localhost:8080&lt;/a&gt;.  What you see should look like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/switchBoard/images/install/3.png&quot; alt=&quot;Unconfigured SwitchBoard web interface.&quot; title=&quot;Unconfigured, but running&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We’ve just confirmed it’s up and running - the software and dependencies all seem to be working.  You can now kill the app and we can begin configuring your new system.  There’s a few basic things to address in the general config options:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/switchBoard/images/install/4.png&quot; alt=&quot;Configuring SwitchBoard.&quot; title=&quot;Configuring SwitchBoard&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You’ll probably want to change at least the &lt;code class=&quot;highlighter-rouge&quot;&gt;serverIp&lt;/code&gt;, but most everything else is set to pretty sane defaults.  Feel free to dabble with them - and if any are not clear, please let me know and I can either clarify, document or rename them to something more appropriate.&lt;/p&gt;

&lt;p&gt;SmartThings is a popular option to control and it works quite well with SwitchBoard - so let’s use that one as an example.  It has some atypical requirements, so we’ll have to first install it’s “companion app” that will live on the SmartThings server.  This companion app is the REST endpoing that SwitchBoard will send commands to and also have the hub send local commands to SwitchBoard to keep it synced up in real time.  Specific, step-by-step instructions are listed in the config file above the SmartThings entry.&lt;/p&gt;

&lt;p&gt;You’ll go to the URL provided in the SmartThings config comment and create a new app.  The SmartThings IDE interface will look something like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/switchBoard/images/install/5.png&quot; alt=&quot;Setting up our SmartThings app.&quot; title=&quot;Setting up our SmartThings app&quot; /&gt;&lt;/p&gt;

&lt;p&gt;When you finish setting up your app, you’ll be given an Oauth “Client ID” and “Client Secret”.  You’ll need to take each of these values and populate the appropriate fields in the config.  Be sure not to share these values with anyone.&lt;/p&gt;

&lt;p&gt;Once our SmartThings app is set up and we’ve gotten the &lt;code class=&quot;highlighter-rouge&quot;&gt;clientId&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;clientSecret&lt;/code&gt; fields populated in our SwitchBoard config file, we can fire up the server to begin the authentication.  You should see a bright console prompt on the server telling you that you’ll need to click a URL to complete the authentication:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/switchBoard/images/install/6.png&quot; alt=&quot;SwitchBoard prompting us to visit a URL to authenticate with SmartThings.&quot; title=&quot;Authenticate with SmartThings&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Once you click that URL, you’ll tell SmartThings which Hub and which devices within that hub to allow SwitchBoard to control.  When you’ve finished filling out the form, SmartThings should forward you back to your SwitchBoard interface.  It may take a second - and it may be helpful (but shouldn’t be necessary) to restart SwitchBoard at this point to ensure your devices are populated correctly.  Your interface should now be populated with all the devices you’ve told SmartThings you wanted to have controlled:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/switchBoard/images/install/7.png&quot; alt=&quot;SwitchBoard interface with a linked SmartThings device.&quot; title=&quot;SwitchBoard with linked SmartThings device&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And that’s it!  You can go through the config file to enable and configure any other devices you wish.  You’ll probably want to mark the &lt;code class=&quot;highlighter-rouge&quot;&gt;welcome&lt;/code&gt; device as &lt;code class=&quot;highlighter-rouge&quot;&gt;disabled: true&lt;/code&gt; and change the &lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt; to a controller ID that’s your favorite (maybe &lt;code class=&quot;highlighter-rouge&quot;&gt;smartthings&lt;/code&gt;?).&lt;/p&gt;</content><author><name></name></author><category term="general" /><category term="setup" /><category term="home automation" /><category term="smartthings" /><summary type="html">To use SwitchBoard, you’ll need a working version of node.js and npm. As node.js can run on a wide variety of platforms, I won’t go into the specifics of getting that set up. There’s documentation available for most platforms that can do a better job of describing all the details there. If you do have issues, I’m happy to try and point you in the right direction, though.</summary></entry><entry><title type="html">Hello World</title><link href="http://localhost:4000/switchBoard/Hello-World/" rel="alternate" type="text/html" title="Hello World" /><published>2017-10-28T00:00:00-07:00</published><updated>2017-10-28T00:00:00-07:00</updated><id>http://localhost:4000/switchBoard/Hello-World</id><content type="html" xml:base="http://localhost:4000/switchBoard/Hello-World/">&lt;p&gt;There was some interest in following development progress.  This is the first step in setting that up.&lt;/p&gt;

&lt;p&gt;The latest work done to SwitchBoard has been the addition of some simple Machine Learning which has garnered some interest.  The more you use the system, it’s able to start determining patterns of use, conditional on the state of current devices, time of day and whether it’s a weekday / weekend.  As one area of focus has always been to support slower machines, with the target install location to be on a Raspberry Pi, there had to be some concessions made to the granularity of specific data points.  For this reason, the time conditions are broken into four 6-hour categories: “Dawn”, “Morning”, “Afternoon” and “Evening”.  Day types are simply bucketed into “Weekday” and “Weekend”  One limitation in this is that if you hit a switch at, say, 11:59am, any explicit pattern found in the afternoon will be ignored.  As this is all based on averages, I suspect the end result will be of no real consequence; thus, a reasonable compromise.&lt;/p&gt;

&lt;p&gt;For now, SwitchBoard tries to draw together these actions but will currently only notify you of it’s intent via the Gery chat log.  Soon, a flag will be added so it may act on these intentions if they fall beyond a specific threshold.  I’ve been waiting to add this ability to initiate action until I’ve built confidence in knowing that it won’t misbehave.&lt;/p&gt;

&lt;p&gt;The Gery chat log is an area where SwitchBoard is able to communicate to users in an unobtrusive way.  Gerty is a “bot” that derives it’s emotional state based on environmental criteria - is everyone home?  Is it sunny?  Is the TV on?  All these can combine to derive an emoji that is displayed and randomly fire animated events to keep things interesting.  Clicking the emoji will - on supported systems - start a voice recognition instance.  Any speech or written text will be read and implied intent will try to be derived.  “Turn on the living room lamp and hall light” will result in those given subdevices to change both states to “on”.  Likewise, it’s able to use this same chat log to let you know if someone was at your front door, if you received a package, when the sun goes down or any number of other “kinda useful” things that you’d like to have a timestamped log of.  I’ll write later about some more specifics of Gerty, what he’s capable of, where he came from and where I hope to integrate into him next.&lt;/p&gt;</content><author><name></name></author><category term="general" /><category term="device" /><category term="machine learning" /><category term="home automation" /><category term="gerty" /><summary type="html">There was some interest in following development progress. This is the first step in setting that up.</summary></entry></feed>